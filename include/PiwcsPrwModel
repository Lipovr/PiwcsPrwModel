#ifndef PIWCS_PRW_MODEL
#define PIWCS_PRW_MODEL

#include <iosfwd>
#include <memory>
#include <string>
#include <unordered_map>

namespace piwcs {
namespace prw {

/**
 * Maximum supported length of identifiers in UTF-8 bytes.
 */
constexpr size_t IDENT_LENGTH = 15;

/**
 * Type alias for identifiers. Effectively a string.
 */
using Identifier = std::string;

/**
 * The Identifier value that should be used to express a lack of an identifier.
 */
extern const Identifier ID_NULL;

/**
 * An invalid identifier.
 *
 * This is not the only possible invalid identifier; use `isId` to check for
 * validity.
 */
extern const Identifier ID_INVALID;

/**
 * Determines if the provided Identifier is valid.
 *
 * Unlike `isId`, this function returns `true` for `ID_NULL`.
 *
 * @return whether the argument is a valid identifier
 */
bool isIdOrNull(const Identifier &);

/**
 * Determines if the provided Identifier is valid and not `ID_NULL`.
 *
 * @return whether the argument is a valid, non-null Identifier value
 *
 * @see isIdOrNull to only test validity
 */
bool isId(const Identifier &);

class Node;
class Section;
class Destination;

/**
 * Model of the Public Railway (PRW) found on PIWCS.
 *
 * The model is fundamentally a directed graph, with switches and section
 * boundaries acting as nodes, and railway track sections acting as edges.
 *
 * ## Class-enforced invariants
 *   - All `unique_ptr`'s are not empty
 *   - Node identifiers are globally unique
 *   - Section identifiers are globally unique
 *   - All identifier slots are either empty or contain IDs of known entities
 *   - Nodes and section connection information is not contradictory
 *   - All Destination objects are valid
 *   - Destination addresses are globally unique
 */
class Model {

    std::unordered_map<Identifier, std::unique_ptr<Node>> m_nodes;
    std::unordered_map<Identifier, std::unique_ptr<Section>> m_sections;

  public:

    /**
     * Provides access to the internal mapping of IDs to all Nodes.
     *
     * The returned reference is valid as long as this Model object exists, and
     * its contents update dynamically as this Model object changes. All
     * `unique_ptr`'s are not empty.
     *
     * @return a mapping of IDs to Nodes.
     */
    const std::unordered_map<Identifier, std::unique_ptr<Node>> &nodes() const {
        return m_nodes;
    }

    /**
     * Provides access to the internal mapping of IDs to all Sections.
     *
     * The returned reference is valid as long as this Model object exists, and
     * its contents update dynamically as this Model object changes. All
     * `unique_ptr`'s are not empty.
     *
     * @return a mapping of IDs to Sections.
     */
    const std::unordered_map<Identifier, std::unique_ptr<Section>> &
    sections() const {
        return m_sections;
    }

    /**
     * Possible return values of `add*` methods.
     */
    enum AddResult {
        /**
         * Addition was successful, the Model has changed.
         */
        ADD_OK,

        /**
         * Addition was aborted because an entity with an identical ID is
         * already present.
         */
        ADD_DUPLICATE,

        /**
         * Addition was aborted because the entity being added has some non-null
         * references to other entities.
         */
        ADD_HAS_REF
    };

    /**
     * Adds an existing Node to the model.
     *
     * The operation may fail if the node with given ID already exists
     * (`ADD_DUPLICATE`), or if the node references any entities
     * (`ADD_HAS_REF`). Should addition fail, all objects remain valid and
     * no change is made.
     *
     * The `unique_ptr` must not be reset.
     *
     * @param node the Node to add.
     *
     * @return `ADD_OK` upon success, `ADD_DUPLICATE` or `ADD_UNKNOWN_REF` upon
     * failure.
     */
    AddResult addNode(std::unique_ptr<Node> node);

    /**
     * Possible return values of `remove*` methods.
     */
    enum RemoveResult {
        /**
         * Removal was successful, the Model has changed.
         */
        REMOVE_OK,

        /**
         * Removal has failed because an entity with such ID could not be found.
         */
        REMOVE_NOT_FOUND,

        /**
         * Removal was aborted because other entities exist that reference the
         * requested entity.
         */
        REMOVE_REFERENCED
    };

    /**
     * Removes a Node from the model.
     *
     * The operation may fail if the node with given ID cannot be found
     * (`REMOVE_NOT_FOUND`), or if the node is still referenced by some entity
     * (`REMOVE_REFERENCED`). Should removal fail, all objects remain valid and
     * no change is made.
     *
     * @param id the ID of the Node to remove.
     *
     * @return `REMOVE_OK` upon success, `REMOVE_NOT_FOUND` or
     * `REMOVE_REFERENCED` upon failure.
     */
    RemoveResult removeNode(const Identifier &id);

    /**
     * Searches for a Node with the given ID.
     *
     * The returned pointer is valid until a change is made to this Model
     * object.
     *
     * @param id the ID of the Node to find
     *
     * @return a raw pointer to the Node, or `nullptr` if none found.
     */
    const Node *node(const Identifier &id);

    /**
     * Searches for a Section with the given ID.
     *
     * The returned pointer is valid until a change is made to this Model
     * object.
     *
     * @param id the ID of the Section to find
     *
     * @return a raw pointer to the Section, or `nullptr` if none found.
     */
    const Section *section(const Identifier &id);
};

/**
 * A Node at the joint or intersection of Sections.
 *
 * Nodes, as all Model entities, are mutable objects.
 */
class Node {

  public:

    /**
     * A kind of Node reflecting its role, structure and function.
     *
     * @see type()
     */
    enum Type {
        /**
         * A node connecting two sections of a single track.
         */
        THRU = 1,

        /**
         * A motorized switch operated by a routing table.
         */
        MOTORIZED = 2,

        /**
         * A switch that cannot be entered from the common track.
         */
        PASSIVE = 3,

        /**
         * A switch that is fixed in a single position that can be entered from
         * the common track.
         */
        FIXED = 4,

        /**
         * A level crossing of two tracks.
         */
        CROSSING = 5,

        /**
         * A dead end connected to a bidirectional section.
         */
        END = 6
    };

  private:
    Type m_type;
    Identifier m_id;

  public:

    /**
     * Constructs a Node with the given type and ID.
     */
    Node(Type type, const Identifier &id) : m_type(type), m_id(id) {}

    virtual ~Node() {}

    /**
     * Returns the Type of this Node.
     *
     * Node Type determines the role, structure and function of the node. Node
     * types are more specific than implementing classes, and multiple types can
     * be implemented by a single class. Use this value to differentiate between
     * different kinds of nodes.
     *
     * @return the Type of this Node.
     */
    Type type() const { return m_type; }

    /**
     * Returns the Identifier of this Node.
     *
     * @return the ID of this Node.
     */
    const Identifier &id() const { return m_id; }

    /**
     * Returns the number of Sections this Node connects.
     *
     * This value is constant for a given Type.
     *
     * @return the number of Sections Nodes of this Type connect
     */
    virtual size_t sectionCount() const = 0;

    /**
     * Returns the ID of the section in the requested slot, `ID_NULL` if the
     * slot is not yet connected, or `ID_INVALID` if no such slot exists.
     *
     * @return the ID of the requested section, `ID_NULL` or `ID_INVALID`.
     */
    virtual const Identifier &section(size_t index) const = 0;

  protected:

    /**
     * Determines whether travel from slot `from` to slot `to` would be possible
     * if appropriate section were connected in these slots.
     *
     * This method must not query actual sections connected, if any.
     *
     * This value is constant for a given (Type, `from`, `to`) tuple. `false` is
     * returned for invalid slots. Note that most, but not all Nodes will return
     * `false` when `from == to`.
     *
     * @return `true` if and only if there exists a configuration of Sections
     * that would permit travel from the Section at slot `from` to the Section
     * at slot `to`
     */
    virtual bool couldTraverse(size_t from, size_t to) const = 0;

    /**
     * Outputs a textual representation of this Node to the `ostream`.
     */
    virtual void print(std::ostream &) const = 0;

    /**
     * Outputs a textual representation of this Node to the `ostream`.
     */
    friend std::ostream &operator<<(std::ostream &, const Node &);
};

class ThruNode : public Node {

    Identifier m_sections[2];

  public:
    ThruNode(const Identifier &);

    virtual size_t sectionCount() const override;
    virtual const Identifier &section(size_t index) const override;

  protected:
    virtual bool couldTraverse(size_t from, size_t to) const override;
    virtual void print(std::ostream &) const override;
};

class SwitchNode : public Node {

    Identifier m_common;
    Identifier m_straight;
    Identifier m_diverging;

  public:
    SwitchNode(Type, const Identifier &);

    const Identifier &common() const { return m_common; }

    const Identifier &straight() const { return m_straight; }

    const Identifier &diverging() const { return m_diverging; }

    virtual size_t sectionCount() const override;
    virtual const Identifier &section(size_t index) const override;

  protected:
    virtual bool couldTraverse(size_t from, size_t to) const override;
    virtual void print(std::ostream &) const override;
};

/**
 * A Section connecting exactly two Nodes.
 *
 * Sections, as all Model entities, are mutable objects.
 */
class Section {

    Identifier m_id;

    Identifier m_start;
    Identifier m_end;
    bool m_bidirectional;

    std::unique_ptr<Destination> m_dest;

  public:
    Section(const Identifier &id);

    const Identifier &id() const { return m_id; }

    const Identifier &start() const { return m_start; }

    const Identifier &end() const { return m_end; }

    bool isBidir() const { return m_bidirectional; }

    const Identifier &node(size_t index) const {
        switch (index) {
        case 0:
            return start();
        case 1:
            return end();
        default:
            return ID_INVALID;
        }
    }

    bool canTraverse(size_t from, size_t to) const {
        if (from == 0 && to == 1)
            return true;
        if (isBidir() && from == 1 && to == 0)
            return true;
        return false;
    }

    bool isDestination() const { return static_cast<bool>(m_dest); }

    const Destination *destination() const { return m_dest.get(); }

    void setDestination(std::unique_ptr<Destination>);

    friend std::ostream &operator<<(std::ostream &, const Section &);
};

struct Destination {

    using Address = std::string;
    using Name = std::string;

    Address address;
    Name name;
};

} // namespace prw
} // namespace piwcs

#endif // PIWCS_PRW_MODEL
