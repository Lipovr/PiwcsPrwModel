#ifndef PIWCS_PRW_MODEL
#define PIWCS_PRW_MODEL

#include <iosfwd>
#include <memory>
#include <string>
#include <unordered_map>

/**
 * @file
 *
 * This header declares the Model describing the PIWCS Public Railway, I/O
 * routines and a few convenience algorithms.
 */

namespace piwcs::prw {

/**
 * Maximum supported length of identifiers in UTF-8 bytes.
 */
constexpr size_t IDENT_LENGTH = 15;

/**
 * Type alias for identifiers. Effectively a string.
 */
using Identifier = std::string;

/**
 * The Identifier value that should be used to express a lack of an identifier.
 */
static const Identifier ID_NULL;

/**
 * An invalid identifier.
 *
 * This is not the only possible invalid identifier; use `isId` to check for
 * validity.
 */
static const Identifier ID_INVALID = "#invalid";

/**
 * Determines if the provided Identifier is valid.
 *
 * Unlike `isId`, this function returns `true` for `ID_NULL`.
 *
 * @return whether the argument is a valid identifier
 */
bool isIdOrNull(const Identifier &);

/**
 * Determines if the provided Identifier is valid and not `ID_NULL`.
 *
 * @return whether the argument is a valid, non-null Identifier value
 *
 * @see isIdOrNull to only test validity
 */
bool isId(const Identifier &);

class Node;
class Section;
class Destination;

/**
 * Model of the Public Railway (PRW) found on PIWCS.
 *
 * The model is fundamentally a directed graph, with switches and section
 * boundaries acting as nodes, and railway track sections acting as edges.
 *
 * @par Class-enforced invariants
 *   - All `unique_ptr`'s are not empty
 *   - Node identifiers are globally unique
 *   - Section identifiers are globally unique
 *   - All identifier slots are either empty or contain IDs of known entities
 *   - Nodes and section connection information is not contradictory
 *   - All Destination objects are valid
 *   - Destination addresses are globally unique
 */
class Model {

    std::unordered_map<Identifier, std::unique_ptr<Node>> m_nodes;
    std::unordered_map<Identifier, std::unique_ptr<Section>> m_sections;

  public:
    /**
     * Provides access to the internal mapping of IDs to all Nodes.
     *
     * The returned reference is valid as long as this Model object exists, and
     * its contents update dynamically as this Model object changes. All
     * `unique_ptr`'s are not empty.
     *
     * @return a mapping of IDs to Nodes
     */
    const std::unordered_map<Identifier, std::unique_ptr<Node>> &nodes() const {
        return m_nodes;
    }

    /**
     * Provides access to the internal mapping of IDs to all Sections.
     *
     * The returned reference is valid as long as this Model object exists, and
     * its contents update dynamically as this Model object changes. All
     * `unique_ptr`'s are not empty.
     *
     * @return a mapping of IDs to Sections
     */
    const std::unordered_map<Identifier, std::unique_ptr<Section>> &
    sections() const {
        return m_sections;
    }

    /**
     * Possible return values of `add*` methods.
     */
    enum AddResult {
        /**
         * Addition was successful, the Model has changed.
         */
        ADD_OK,

        /**
         * Addition was aborted because an entity with an identical ID is
         * already present.
         */
        ADD_DUPLICATE,

        /**
         * Addition was aborted because the entity being added has some non-null
         * references to other entities.
         */
        ADD_HAS_REF
    };

    /**
     * Adds an existing Node to the model.
     *
     * The operation may fail if the node with given ID already exists
     * (`ADD_DUPLICATE`), or if the node references any entities
     * (`ADD_HAS_REF`). Should addition fail, all objects remain valid and
     * no change is made.
     *
     * The `unique_ptr` must not be empty.
     *
     * @param node the Node to add
     *
     * @return `ADD_OK` upon success, `ADD_DUPLICATE` or `ADD_UNKNOWN_REF` upon
     * failure
     */
    AddResult addNode(std::unique_ptr<Node> node);

    /**
     * Possible return values of `remove*` methods.
     */
    enum RemoveResult {
        /**
         * Removal was successful, the Model has changed.
         */
        REMOVE_OK,

        /**
         * Removal has failed because an entity with such ID could not be found.
         */
        REMOVE_NOT_FOUND,

        /**
         * Removal was aborted because other entities exist that reference the
         * requested entity.
         */
        REMOVE_REFERENCED
    };

    /**
     * Removes a Node from the model.
     *
     * The operation may fail if the node with given ID cannot be found
     * (`REMOVE_NOT_FOUND`), or if the node is still referenced by some entity
     * (`REMOVE_REFERENCED`). Should removal fail, all objects remain valid and
     * no change is made.
     *
     * @param id the ID of the Node to remove
     *
     * @return `REMOVE_OK` upon success, `REMOVE_NOT_FOUND` or
     * `REMOVE_REFERENCED` upon failure
     */
    RemoveResult removeNode(const Identifier &id);

    /**
     * Searches for a Node with the given ID.
     *
     * The returned pointer is valid until a change is made to this Model
     * object.
     *
     * @param id the ID of the Node to find
     *
     * @return a raw pointer to the Node, or `nullptr` if none found
     */
    const Node *node(const Identifier &id);

    /**
     * Searches for a Section with the given ID.
     *
     * The returned pointer is valid until a change is made to this Model
     * object.
     *
     * @param id the ID of the Section to find
     *
     * @return a raw pointer to the Section, or `nullptr` if none found
     */
    const Section *section(const Identifier &id);
};

/**
 * A Node at the joint or intersection of Sections.
 *
 * Nodes, as all Model entities, are mutable objects.
 */
class Node {

  public:
    /**
     * A kind of Node reflecting its role, structure and function.
     *
     * @see type()
     */
    enum Type {
        /**
         * A node connecting two sections of a single track.
         */
        THRU = 1,

        /**
         * A motorized switch operated by a routing table.
         */
        MOTORIZED = 2,

        /**
         * A switch that cannot be entered from the common track.
         */
        PASSIVE = 3,

        /**
         * A switch that is fixed in a single position that can be entered from
         * the common track.
         */
        FIXED = 4,

        /**
         * A level crossing of two tracks.
         */
        CROSSING = 5,

        /**
         * A dead end connected to a bidirectional section.
         */
        END = 6
    };

  private:
    Type m_type;
    Identifier m_id;

  public:
    /**
     * Constructs a Node with the given type and ID.
     */
    Node(Type type, Identifier id) : m_type(type), m_id(std::move(id)) {}

    virtual ~Node() = default;

    /**
     * Returns the Type of this Node.
     *
     * Node Type determines the role, structure and function of the node. Node
     * types are more specific than implementing classes, and multiple types can
     * be implemented by a single class. Use this value to differentiate between
     * different kinds of nodes.
     *
     * @return the Type of this Node
     */
    [[nodiscard]] Type type() const { return m_type; }

    /**
     * Returns the Identifier of this Node.
     *
     * @return the ID of this Node
     */
    [[nodiscard]] const Identifier &id() const { return m_id; }

    /**
     * Returns the number of Sections this Node connects.
     *
     * This value is constant for a given Type.
     *
     * @return the number of Sections Nodes of this Type connect
     */
    [[nodiscard]] virtual size_t sectionCount() const = 0;

    /**
     * Returns the ID of the section in the requested slot, `ID_NULL` if the
     * slot is not yet connected, or `ID_INVALID` if no such slot exists.
     *
     * @return the ID of the requested section, `ID_NULL` or `ID_INVALID`
     */
    [[nodiscard]] virtual const Identifier &section(size_t index) const = 0;

    /**
     * Determines whether travel from slot `from` to slot `to` would be possible
     * if appropriate section were connected in these slots.
     *
     * This method must not query actual sections connected, if any.
     *
     * This value is constant for a given (Type, `from`, `to`) tuple. `false` is
     * returned for invalid slots. Note that most, but not all Nodes will return
     * `false` when `from == to`.
     *
     * @return `true` if and only if there exists a configuration of Sections
     * that would permit travel from the Section at slot `from` to the Section
     * at slot `to`
     */
    [[nodiscard]] virtual bool couldTraverse(size_t from, size_t to) const = 0;

  protected:
    /**
     * Outputs a textual representation of this Node to the `ostream`.
     */
    virtual void print(std::ostream &) const = 0;

    /**
     * Outputs a textual representation of this Node to the `ostream`.
     */
    friend std::ostream &operator<<(std::ostream &, const Node &);
};

/**
 * A node connecting two sections of a single track. Its Type is `ThruNode`.
 *
 * Use `section(0)` and `section(1)` to access connections.
 */
class ThruNode : public Node {

    Identifier m_sections[2];

  public:
    /**
     * Constructs a new thru node with the given ID.
     */
    ThruNode(const Identifier &);

    [[nodiscard]] size_t sectionCount() const override { return 2; }

    [[nodiscard]] const Identifier &section(size_t index) const override;

    [[nodiscard]] bool couldTraverse(size_t from, size_t to) const override;

  protected:
    void print(std::ostream &) const override;
};

/**
 * A switch with three connected tracks. Switches can have one of three Types:
 * `MOTORIZED`, `PASSIVE` or `FIXED`.
 *
 * @par Switch structure
 *
    @dot
    graph switch {
        node [shape = plaintext];
        common [layer = 0];
        straight [layer = 2];
        diverging [layer = 2];
        switch [layer = 1];
        common -- switch -- straight;
        switch -- diverging [style = "dashed"];
    }
    @enddot
 *
 * Switches physically prohibit travel between straight and diverging tracks.
 * When a train enters the switch from its straight or diverging track, it is
 * directed into the common track. When a train enters the switch from its
 * common track, the switch chooses a track to direct it towards..
 *
 * `MOTORIZED` switches can only be entered from the common track. A routing
 * table consulted to determine whether the train should be diverted. For
 * motorized switches, straight track is the default direction.
 *
 * `PASSIVE` switches can only be exited from the common track. As such, they
 * require no controller. For passive switches, straight track choice is
 * arbitrary.
 *
 * `FIXED` switches can be entered from the common track, but will always direct
 * all trains to the same exit. They are usually found at the edges of
 * bidirectional segments. For fixed switches, straight track is the exit for
 * trains entering through common track.
 *
 * (All other switch configurations are invalid on the PRW.)
 */
class SwitchNode : public Node {

    Identifier m_common;
    Identifier m_straight;
    Identifier m_diverging;

  public:
    /**
     * Constructs a SwitchNode with the given type and ID.
     *
     * Type must be one of `MOTORIZED`, `PASSIVE` and `FIXED`.
     */
    SwitchNode(Type, Identifier);

    /**
     * Returns the section ID of the common track.
     *
     * Equivalent to `section(0)`.
     *
     * @return section ID of the common track or `ID_NULL`
     */
    [[nodiscard]] const Identifier &common() const { return m_common; }

    /**
     * Returns the section ID of the straight track.
     *
     * Equivalent to `section(1)`.
     *
     * @return section ID of the straight track or `ID_NULL`
     */
    [[nodiscard]] const Identifier &straight() const { return m_straight; }

    /**
     * Returns the section ID of the diverging track.
     *
     * Equivalent to `section(2)`.
     *
     * @return section ID of the diverging track or `ID_NULL`
     */
    [[nodiscard]] const Identifier &diverging() const { return m_diverging; }

    [[nodiscard]] size_t sectionCount() const override { return 3; }

    /**
     * @copydoc Node::section
     *
     * @par Layout of switches
     *   - 0: common track
     *   - 1: straight track
     *   - 2: diverging track
     *
     * @see common
     * @see straight
     * @see diverging
     */
    [[nodiscard]] const Identifier &section(size_t index) const override;

    [[nodiscard]] bool couldTraverse(size_t from, size_t to) const override;

  protected:
    void print(std::ostream &) const override;
};

/**
 * A Section connecting exactly two Nodes.
 *
 * Sections usually allow travel in one direction only, from start to end.
 * If not, the Section is said to be bidirectional, in which case start and end
 * are chosen arbitrarily.
 *
 * Some Sections are destinations and own a Destination object.
 *
 * Sections, as all Model entities, are mutable objects.
 */
class Section {

    Identifier m_id;

    Identifier m_start;
    Identifier m_end;
    bool m_bidirectional;

    std::unique_ptr<Destination> m_dest;

  public:
    /**
     * Constructs a new Section with the given ID and directionality
     */
    Section(Identifier, bool isBidir);

    /**
     * Returns the Identifier of this Section.
     *
     * @return the ID of this section
     */
    [[nodiscard]] const Identifier &id() const { return m_id; }

    /**
     * Returns the ID of the Node at the start of this Section.
     *
     * Equivalent to `node(0)`.
     *
     * @return the ID of the start Node or `ID_NULL`
     */
    [[nodiscard]] const Identifier &start() const { return m_start; }

    /**
     * Returns the ID of the Node at the end of this Section.
     *
     * Equivalent to `node(1)`.
     *
     * @return the ID of the end Node or `ID_NULL`
     */
    [[nodiscard]] const Identifier &end() const { return m_end; }

    /**
     * Returns `true` iff the Section is bidirectional, i.e. allows travel from
     * end to start.
     *
     * @return whether this Section is bidirectional
     */
    [[nodiscard]] bool isBidir() const { return m_bidirectional; }

    /**
     * Returns the ID of the node at the given index. This is a convenience
     * method to generalize `start()` and `end()`.
     *
     * Index 0 corresponds to `start`, index 1 corresponds to `end`. All other
     * indices return `ID_INVALID`.
     *
     * @param index index of the Node slot to return
     *
     * @return the ID of the Node in the slot with index `index`, `ID_NULL` if
     * the slot is empty, or `ID_INVALID` if the slot does not exist
     */
    [[nodiscard]] const Identifier &node(size_t index) const {
        switch (index) {
        case 0:
            return start();
        case 1:
            return end();
        default:
            return ID_INVALID;
        }
    }

    /**
     * Checks whether travel is allowed from Node in slot with index `from` to
     * Node in slot with index `to`.
     *
     * See @ref Section::node for layout.
     *
     * Travel is always allowed from 0 to 1. If this Section is bidirectional,
     * travel is additionally allowed from 1 to 0. All other inputs return
     * `false`.
     *
     * @param from index of starting Node
     * @param to index of ending Node
     *
     * @return `true` if and only if travel is possible and allowed in given
     * direction
     */
    [[nodiscard]] bool canTraverse(size_t from, size_t to) const {
        return (from == 0 && to == 1) || (isBidir() && from == 1 && to == 0);
    }

    /**
     * Returns `true` iff this Section has Destination data.
     *
     * @return whether this Section is a destination
     */
    [[nodiscard]] bool isDestination() const {
        return static_cast<bool>(m_dest);
    }

    /**
     * Returns the Destination data for this Section, if any.
     *
     * The returned pointer is valid until `setDestination` is called on this
     * Section object or this Section object is destroyed.
     *
     * @return a raw pointer to the Destination object describing this
     * destination, or `nullptr`
     */
    [[nodiscard]] const Destination *destination() const {
        return m_dest.get();
    }

    /**
     * Changes the destination data of this Section.
     *
     * If `data` is not empty, this Section becomes a destination described by
     * the provided object which becomes owned by this Section. Any previous
     * destination data is discarded and Destination objects deleted.
     *
     * If `data` is empty, this Section ceases to be destination if it was one.
     * Any previous destination data is discarded and Destination objects
     * deleted.
     *
     * @param data new destination data or `nullptr`
     */
    void setDestination(std::unique_ptr<Destination> data);

    /**
     * Outputs a textual representation of this Section to the `ostream`.
     */
    friend std::ostream &operator<<(std::ostream &, const Section &);
};

/**
 * A description of a destination.
 *
 * These objects may be attached to Sections to turn them into destinations.
 *
 * Destinations, as all Model entities, are mutable objects.
 */
struct Destination {

    /**
     * Type alias for addresses. Effectively a string.
     */
    using Address = std::string;

    /**
     * Type alias for names. Effectively a string.
     */
    using Name = std::string;

    /**
     * The address of this Destination.
     *
     * An address is a machine-friendly identifier of a destination. They are
     * used for routing.
     *
     * Addresses must be ASCII-encoded strings.
     */
    Address address;

    /**
     * The name of this Destination.
     *
     * A name is a user-friendly label for the destination.
     *
     * Names must not be inspected and may use any encoding.
     */
    Name name;
};

} // namespace piwcs::prw

#endif // PIWCS_PRW_MODEL
