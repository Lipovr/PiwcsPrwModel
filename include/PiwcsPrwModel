#ifndef PIWCS_PRW_MODEL
#define PIWCS_PRW_MODEL

#include <iosfwd>
#include <memory>
#include <stdexcept>
#include <string>
#include <unordered_map>

/**
 * @file
 *
 * This header declares the Model describing the PIWCS Public Railway, I/O
 * routines and a few convenience algorithms.
 */

namespace piwcs::prw {

/**
 * Maximum supported length of identifiers in UTF-8 bytes.
 */
constexpr size_t IDENT_LENGTH = 15;

/**
 * Type alias for identifiers. Effectively a string.
 */
using Identifier = std::string;

/**
 * The Identifier value that should be used to express a lack of an identifier.
 */
static const Identifier ID_NULL;

/**
 * An invalid identifier.
 *
 * This is not the only possible invalid identifier; use `isId` to check for
 * validity.
 */
static const Identifier ID_INVALID = "#invalid";

/**
 * Determines if the provided Identifier is valid.
 *
 * Unlike `isId`, this function returns `true` for `ID_NULL`.
 *
 * @return whether the argument is a valid identifier
 */
bool isIdOrNull(const Identifier &);

/**
 * Determines if the provided Identifier is valid and not `ID_NULL`.
 *
 * @return whether the argument is a valid, non-null Identifier value
 *
 * @see isIdOrNull to only test validity
 */
bool isId(const Identifier &);

/**
 * Type alias for Node and Section slots. Effectively an unsigned integer.
 */
using SlotId = size_t;

class Node;
class NodeSlot;
class Section;
class Destination;

/**
 * Model of the Public Railway (PRW) found on PIWCS.
 *
 * The model is fundamentally a directed graph, with switches and section
 * boundaries acting as nodes, and railway track sections acting as edges.
 *
 * A model that conforms to all Model invariants (see below) is said to be
 * _consistent_. A model that additionally has no empty slots is said to be
 * _complete_.
 *
 * @par Class-enforced invariants
 *   - All `unique_ptr`'s are not empty
 *   - Node identifiers are valid, non-null and globally unique
 *   - Section identifiers are valid, non-null and globally unique
 *   - All identifier slots are either empty or contain IDs of known entities
 *   - Nodes and section connection information is internally consistent
 *   - All Destination objects are valid
 *   - Destination addresses are globally unique
 */
class Model {

    std::unordered_map<Identifier, std::unique_ptr<Node>> m_nodes;
    std::unordered_map<Identifier, std::unique_ptr<Section>> m_sections;

  public:
    /**
     * Provides access to the internal mapping of IDs to all Nodes.
     *
     * The returned reference is valid as long as this Model object exists, and
     * its contents update dynamically as this Model object changes. All
     * `unique_ptr`'s are not empty.
     *
     * @return a mapping of IDs to Nodes
     */
    const std::unordered_map<Identifier, std::unique_ptr<Node>> &nodes() const {
        return m_nodes;
    }

    /**
     * Provides access to the internal mapping of IDs to all Sections.
     *
     * The returned reference is valid as long as this Model object exists, and
     * its contents update dynamically as this Model object changes. All
     * `unique_ptr`'s are not empty.
     *
     * @return a mapping of IDs to Sections
     */
    const std::unordered_map<Identifier, std::unique_ptr<Section>> &
    sections() const {
        return m_sections;
    }

    /**
     * Possible return values of `add*` methods.
     */
    enum class AddResult {
        /**
         * Addition was successful, the Model has changed.
         */
        OK,

        /**
         * Addition was aborted because the ID is null or invalid.
         */
        BAD_ID,

        /**
         * Addition was aborted because an entity with an identical ID is
         * already present.
         */
        DUPLICATE,

        /**
         * Addition was aborted because the entity being added has some non-null
         * references to other entities.
         */
        HAS_REF
    };

    /**
     * Adds an existing Node to the model.
     *
     * The operation may fail if the node with given ID already exists
     * (`DUPLICATE`), or if the node references any entities (`HAS_REF`). Should
     * addition fail, all objects remain valid and no change is made.
     *
     * The `unique_ptr` must not be empty.
     *
     * @param node the Node to add
     *
     * @return `OK` upon success, `DUPLICATE` or `UNKNOWN_REF` upon failure
     */
    AddResult addNode(std::unique_ptr<Node> node);

    /**
     * Adds an existing Section to the model.
     *
     * The operation may fail if the section with given ID already exists
     * (`DUPLICATE`), if the section is a destination and another destination
     * with the same address already exists (`DUPLICATE`), or if the section
     * references any entities (`HAS_REF`). Should addition fail, all objects
     * remain valid and no change is made.
     *
     * The `unique_ptr` must not be empty.
     *
     * @param node the Section to add
     *
     * @return `OK` upon success, `DUPLICATE` or `UNKNOWN_REF` upon failure
     */
    AddResult addSection(std::unique_ptr<Section> section);

    /**
     * Possible return values of `remove*` methods.
     */
    enum class RemoveResult {
        /**
         * Removal was successful, the Model has changed.
         */
        OK,

        /**
         * Removal has failed because an entity with such ID could not be found.
         */
        NOT_FOUND,

        /**
         * Removal was aborted because other entities exist that reference the
         * requested entity.
         */
        REFERENCED
    };

    /**
     * Removes a Node from the model.
     *
     * The operation may fail if the node with given ID cannot be found
     * (`NOT_FOUND`), or if the node is still referenced by some entity
     * (`REFERENCED`). Should removal fail, all objects remain valid and no
     * change is made.
     *
     * @param id the ID of the Node to remove
     *
     * @return `OK` upon success, `NOT_FOUND` or `REFERENCED` upon failure
     */
    RemoveResult removeNode(const Identifier &id);

    /**
     * Removes a Section from the model.
     *
     * The operation may fail if the section with given ID cannot be found
     * (`NOT_FOUND`), or if the section is still referenced by some entity
     * (`REFERENCED`). Should removal fail, all objects remain valid and no
     * change is made.
     *
     * @param id the ID of the Section to remove
     *
     * @return `OK` upon success, `NOT_FOUND` or `REFERENCED` upon failure
     */
    RemoveResult removeSection(const Identifier &id);

    /**
     * Possible return values of `link` method.
     */
    enum class LinkResult {
        /**
         * Linkage was successful, the Model has changed.
         */
        OK,

        /**
         * Linkage was aborted because some of the nodes, section or slots could
         * not be found.
         */
        NOT_FOUND,

        /**
         * Linkage was aborted because one of the nodes is already occupied.
         */
        NODE_OCCUPIED,

        /**
         * Linkage was aborted because the section is already occupied.
         */
        SECTION_OCCUPIED,

        /**
         * Linkage was aborted because the start and the end are the same slot
         * of the same node.
         */
        SAME_SLOT
    };

    /**
     * Links two Nodes using a Section.
     *
     * The operation may fail if some of the IDs cannot be resolved to existing
     * entities (`NOT_FOUND`), some requested slot does not exist in its Node
     * (`NOT_FOUND`), some slot is already connected (`NODE_OCCUPIED`), the
     * section is already linking some Nodes (`SECTION_OCCUPIED`), or
     * `startNode == endNode && startSlotId == endSlotId` (`SAME_SLOT`).
     *
     * @param sectionId ID of the section to use
     * @param startNodeId ID of the Node to connect to the start of the section
     * @param startSlotId SlotId of the start Node to connect to
     * @param endNodeId ID of the Node to connect to the end of the section
     * @param endSlotId SlotId of the end Node to connect to
     *
     * @return `OK` upon success, `NOT_FOUND`, `NODE_OCCUPIED`,
     * `SECTION_OCCUPIED` or `SAME_SLOT` upon failure
     */
    LinkResult link(const Identifier &sectionId, const Identifier &startNodeId,
                    SlotId startSlotId, const Identifier &endNodeId,
                    SlotId endSlotId);

    /**
     * Searches for a Node with the given ID.
     *
     * The returned pointer is valid until a change is made to this Model
     * object.
     *
     * @param id the ID of the Node to find
     *
     * @return a raw pointer to the Node, or `nullptr` if none found
     */
    const Node *node(const Identifier &id);

    /**
     * Searches for a Section with the given ID.
     *
     * The returned pointer is valid until a change is made to this Model
     * object.
     *
     * @param id the ID of the Section to find
     *
     * @return a raw pointer to the Section, or `nullptr` if none found
     */
    const Section *section(const Identifier &id);
};

struct NodeTypeInfo;

/**
 * A kind of Node reflecting its role, structure and function.
 *
 * ### Switches
 *
 * A switch with three connected tracks. Switches can have one of three Types:
 * `MOTORIZED`, `PASSIVE` or `FIXED`.
 *
 * @par Switch structure
 *
    @dot
    graph switch {
        node [shape = plaintext];
        common [layer = 0];
        straight [layer = 2];
        diverging [layer = 2];
        switch [layer = 1];
        common -- switch -- straight;
        switch -- diverging [style = "dashed"];
    }
    @enddot
 *
 * Switches physically prohibit travel between straight and diverging tracks.
 * When a train enters the switch from its straight or diverging track, it is
 * directed into the common track. When a train enters the switch from its
 * common track, the switch chooses a track to direct it towards..
 *
 * `MOTORIZED` switches can only be entered from the common track. A routing
 * table consulted to determine whether the train should be diverted. For
 * motorized switches, straight track is the default direction.
 *
 * `PASSIVE` switches can only be exited from the common track. As such, they
 * require no controller. For passive switches, straight track choice is
 * arbitrary.
 *
 * `FIXED` switches can only be entered from the common track, and will always
 * direct all trains to the same exit. They are found at the edges of
 * bidirectional segments. For fixed switches, straight track is the exit for
 * trains entering through common track.
 *
 * (All other switch configurations are invalid on the PRW.)
 *
 */
using NodeType = const NodeTypeInfo *;

/**
 * A node connecting two sections of a single track.
 */
extern const NodeType THRU;

/**
 * A motorized switch operated by a routing table.
 */
extern const NodeType MOTORIZED;

/**
 * A switch that cannot be entered from the common track.
 */
extern const NodeType PASSIVE;

/**
 * A switch that is fixed in a single position that can be entered from
 * the common track.
 */
extern const NodeType FIXED;

/**
 * A level crossing of two tracks.
 */
extern const NodeType CROSSING;

/**
 * A dead end connected to a bidirectional section.
 */
extern const NodeType END;

/**
 * A Node at the joint or intersection of Sections.
 *
 * Nodes, as all Model entities, are mutable objects.
 */
class Node {

  public:
    static constexpr size_t MAX_SLOTS = 4;

  private:
    NodeType m_type;
    Identifier m_id;
    Identifier m_slots[MAX_SLOTS];

  public:
    /**
     * Constructs a Node with the given type and ID.
     */
    Node(NodeType, Identifier);

    /**
     * Returns the Type of this Node.
     *
     * Node Type determines the role, structure and function of the node. Node
     * types are more specific than implementing classes, and multiple types can
     * be implemented by a single class. Use this value to differentiate between
     * different kinds of nodes.
     *
     * @return the Type of this Node
     */
    [[nodiscard]] NodeType type() const { return m_type; }

    /**
     * Returns the Identifier of this Node.
     *
     * @return the ID of this Node
     */
    [[nodiscard]] const Identifier &id() const { return m_id; }

    /**
     * Returns the number of Sections this Node connects.
     *
     * This value is constant for a given Type.
     *
     * @return the number of Sections Nodes of this Type connect
     */
    [[nodiscard]] SlotId sectionCount() const;

    /**
     * Returns the ID of the section in the requested slot, `ID_NULL` if the
     * slot is not yet connected, or `ID_INVALID` if no such slot exists.
     *
     * @return the ID of the requested section, `ID_NULL` or `ID_INVALID`
     */
    [[nodiscard]] const Identifier &section(SlotId slot) const {
        return slot > sectionCount() ? ID_INVALID : m_slots[slot];
    }

    /**
     * Determines whether travel from slot `from` to slot `to` would be possible
     * if appropriate section were connected in these slots.
     *
     * This method must not query actual sections connected, if any.
     *
     * This value is constant for a given (Type, `from`, `to`) tuple. `false` is
     * returned for invalid slots. Note that most, but not all Nodes will return
     * `false` when `from == to`.
     *
     * @return `true` if and only if there exists a configuration of Sections
     * that would permit travel from the Section at slot `from` to the Section
     * at slot `to`
     */
    [[nodiscard]] bool couldTraverse(SlotId from, SlotId to) const;

    /**
     * Outputs a textual representation of this Node to the `ostream`.
     */
    friend std::ostream &operator<<(std::ostream &, const Node &);
};

/**
 * SlotId of the common track.
 */
static constexpr SlotId COMMON = 0;

/**
 * SlotId of the straight track.
 */
static constexpr SlotId STRAIGHT = 1;

/**
 * SlotId of the diverging track.
 */
static constexpr SlotId DIVERGING = 2;

/**
 * A Section connecting exactly two Nodes.
 *
 * Sections usually allow travel in one direction only, from start to end.
 * If not, the Section is said to be bidirectional, in which case start and end
 * are chosen arbitrarily.
 *
 * Some Sections are destinations and own a Destination object.
 *
 * Sections, as all Model entities, are mutable objects.
 */
class Section {

  public:
    using Length = uint32_t;

  private:
    Identifier m_id;

    Identifier m_start;
    Identifier m_end;
    bool m_bidirectional;

    Length m_length;

    std::unique_ptr<Destination> m_dest;

  public:
    /**
     * Constructs a new Section with the given ID, directionality, and,
     * optionally, length, destination data.
     */
    Section(Identifier, bool isBidir, Length length = 0,
            std::unique_ptr<Destination> dest = nullptr);

    /**
     * Returns the Identifier of this Section.
     *
     * @return the ID of this section
     */
    [[nodiscard]] const Identifier &id() const { return m_id; }

    /**
     * Returns the ID of the Node at the start of this Section.
     *
     * Equivalent to `node(0)`.
     *
     * @return the ID of the start Node or `ID_NULL`
     */
    [[nodiscard]] const Identifier &start() const { return m_start; }

    /**
     * Returns the ID of the Node at the end of this Section.
     *
     * Equivalent to `node(1)`.
     *
     * @return the ID of the end Node or `ID_NULL`
     */
    [[nodiscard]] const Identifier &end() const { return m_end; }

    /**
     * Returns `true` iff the Section is bidirectional, i.e. allows travel from
     * end to start.
     *
     * @return whether this Section is bidirectional
     */
    [[nodiscard]] bool isBidir() const { return m_bidirectional; }

    /**
     * Returns the ID of the node at the given index. This is a convenience
     * method to generalize `start()` and `end()`.
     *
     * Index 0 corresponds to `start`, index 1 corresponds to `end`. All other
     * indices return `ID_INVALID`.
     *
     * @param index index of the Node slot to return
     *
     * @return the ID of the Node in the slot with index `index`, `ID_NULL` if
     * the slot is empty, or `ID_INVALID` if the slot does not exist
     */
    [[nodiscard]] const Identifier &node(size_t index) const {
        switch (index) {
        case 0:
            return start();
        case 1:
            return end();
        default:
            return ID_INVALID;
        }
    }

    /**
     * Checks whether travel is allowed from Node in slot with index `from` to
     * Node in slot with index `to`.
     *
     * See @ref Section::node for layout.
     *
     * Travel is always allowed from 0 to 1. If this Section is bidirectional,
     * travel is additionally allowed from 1 to 0. All other inputs return
     * `false`.
     *
     * @param from index of starting Node
     * @param to index of ending Node
     *
     * @return `true` if and only if travel is possible and allowed in given
     * direction
     */
    [[nodiscard]] bool canTraverse(size_t from, size_t to) const {
        return (from == 0 && to == 1) || (isBidir() && from == 1 && to == 0);
    }

    /**
     * Returns the length of this section.
     *
     * Length can be zero exactly, meaning it is negligeable. Otherwise it
     * should be significantly greater than zero.
     *
     * @return the lenght of this section
     */
    [[nodiscard]] Length length() const { return m_length; }

    /**
     * Returns `true` iff this Section has Destination data.
     *
     * @return whether this Section is a destination
     */
    [[nodiscard]] bool isDestination() const {
        return static_cast<bool>(m_dest);
    }

    /**
     * Returns the Destination data for this Section, if any.
     *
     * The returned pointer is valid until `setDestination` is called on this
     * Section object or this Section object is destroyed.
     *
     * @return a raw pointer to the Destination object describing this
     * destination, or `nullptr`
     */
    [[nodiscard]] const Destination *destination() const {
        return m_dest.get();
    }

    /**
     * Outputs a textual representation of this Section to the `ostream`.
     */
    friend std::ostream &operator<<(std::ostream &, const Section &);
};

/**
 * A description of a destination.
 *
 * These objects may be attached to Sections to turn them into destinations.
 *
 * Destinations are immutable objects.
 */
class Destination {

  public:
    /**
     * Type alias for addresses. Effectively a string.
     */
    using Address = std::string;

    /**
     * Type alias for names. Effectively a string.
     */
    using Name = std::string;

  private:
    Address m_address;
    Name m_name;

  public:
    /**
     * Creates a new Destination with given address and name.
     */
    Destination(Address address, Name name)
        : m_address(std::move(address)), m_name(std::move(name)) {}

    /**
     * Returns the address of this Destination.
     *
     * An address is a machine-friendly identifier of a destination. They are
     * used for routing.
     *
     * Addresses must be ASCII-encoded strings.
     *
     * @return the address of this Destination
     */
    [[nodiscard]] const Address &address() const { return m_address; }

    /**
     * Returns the name of this Destination.
     *
     * A name is a user-friendly label for the destination.
     *
     * Names must not be inspected and may use any encoding.
     *
     * @return the name of this Destination
     */
    [[nodiscard]] const Name &name() const { return m_name; }
};

/**
 * Reports that `readModel` attempted to construct an illegal Model.
 *
 * This exception is _not_ raised by any methods of Model itself.
 */
class IllegalModelError : public std::runtime_error {
  public:
    IllegalModelError(const std::string &what_arg)
        : std::runtime_error(what_arg) {}
    IllegalModelError(const char *what_arg) : std::runtime_error(what_arg) {}
};

/**
 * Reads a PRW model definition from the provided `istream`, constructs a new
 * Model object and returns it.
 *
 * Note that this function does not guarantee that the resulting Model is
 * complete, only that it is consistent.
 *
 * @exception std::ios_base::failure if an IO error occurs or if data is
 * formatted incorrectly
 * @exception IllegalModelError if the data describes an inconsistent Model
 *
 * @param in an input stream open in binary mode to read the definition from
 *
 * @return the Model desribed by the data in `in`
 */
Model readModel(std::istream &in);

/**
 * Reads a PRW model definition from the file `filename`, constructs a new
 * Model object and returns it.
 *
 * Note that this function does not guarantee that the resulting Model is
 * complete, only that it is consistent.
 *
 * @exception std::ios_base::failure if an IO error occurs or if data is
 * formatted incorrectly
 * @exception IllegalModelError if the data describes an inconsistent Model
 *
 * @param filename the relative path of the file to read
 *
 * @return the Model desribed by the data in `in`
 */
Model readModel(const std::string &filename);

/**
 * Writes the PRW model definition of the provided Model into the output stream.
 *
 * @exception std::ios_base::failure if an IO error occurs
 *
 * @param out an output stream open in binary mode to write the definition to
 * @param model the Model to serialize
 */
void writeModel(std::ostream &out, const Model &model);

/**
 * Writes the PRW model definition of the provided Model into file `filename`.
 *
 * Existing files will be overwritten silently.
 *
 * @exception std::ios_base::failure if an IO error occurs
 *
 * @param filename the relative path of the file to write into
 * @param model the Model to serialize
 */
void writeModel(const std::string &filename, const Model &model);

} // namespace piwcs::prw

#endif // PIWCS_PRW_MODEL
